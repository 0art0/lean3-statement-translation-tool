[{"failed_translations":[{"args":"{p : ℕ} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : ℕ} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : ℕ} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : ℕ} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : ℕ} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : ℕ} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : ℕ} (hp : nat.prime p)","name":"nat.prime.odd","type":"odd p"},{"args":"{p : ℕ} (hp : nat.prime p)","name":"nat.prime.odd","type":"odd p "},{"args":"{p : ℕ} [fact (nat.prime p)]","name":"nat.prime_odd","type":" odd p"},{"args":"{p : ℕ} [fact (nat.prime p)]","name":"nat.prime.odd","type":" odd p"}],"prompt":"/-- If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`. -/ \n theorem nat.eq_prime_pow_of_dvd_least_prime_pow{a p k : ℕ} (pp : nat.prime p) (h₁ : ¬a ∣ p ^ k) (h₂ : a ∣ p ^ (k + 1)):a = p ^ (k + 1)\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/ \n theorem is_prime_pow_iff_pow_succ{R : Type u_1} [comm_monoid_with_zero R] (n : R):is_prime_pow n ↔ ∃ (p : R) (k : ℕ), prime p ∧ p ^ (k + 1) = n\n\n/-- In a finite field of odd characteristic, not every element is a square. -/ \n theorem finite_field.exists_nonsquare{F : Type u_3} [field F] [fintype F] (hF : ring_char F ≠ 2):∃ (a : F), ¬is_square a\n\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/ \n theorem nat.mem_factors_mul_right{p a b : ℕ} (hpb : p ∈ b.factors) (ha : a ≠ 0):p ∈ (a * b).factors\n\n/-- The only divisors of prime powers are prime powers. -/ \n theorem associates.eq_pow_find_of_dvd_irreducible_pow{α : Type u_1} [cancel_comm_monoid_with_zero α] [unique_factorization_monoid α] {a p : associates α} (hp : irreducible p) [Π (n : ℕ), decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n):a = p ^ nat.find _\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/ \n theorem is_prime_pow_iff_unique_prime_dvd{n : ℕ}:is_prime_pow n ↔ ∃! (p : ℕ), nat.prime p ∧ p ∣ n\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/ \n theorem bernoulli'_odd_eq_zero{n : ℕ} (h_odd : odd n) (hlt : 1 < n):bernoulli' n = 0\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/ \n theorem nat.mem_factors_mul_left{p a b : ℕ} (hpa : p ∈ a.factors) (hb : b ≠ 0):p ∈ (a * b).factors\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/ \n theorem nat.even_pow{m n : ℕ}:even (m ^ n) ↔ even m ∧ n ≠ 0\n\n/-- Every nonzero natural number has a unique prime factorization -/ \n theorem nat.factorization_inj:set.inj_on nat.factorization {x : ℕ | x ≠ 0}\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/ \n theorem zmod.wilsons_lemma(p : ℕ) [fact (nat.prime p)]:↑((p - 1).factorial) = -1\n\n/-- The only prime factor of prime `p` is `p` itself, with multiplicity `1` -/ \n theorem nat.prime.factorization{p : ℕ} (hp : nat.prime p):p.factorization = finsupp.single p 1\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/ \n theorem nat.factorization_eq_zero_iff(n : ℕ):n.factorization = 0 ↔ n = 0 ∨ n = 1\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/ \n theorem nat.odd_mod_four_iff{n : ℕ}:n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/ \n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ℕ} [fact (nat.prime p)]:p % 2 = 1 ↔ p ≠ 2\n\n/-- Every prime number is odd -/\ntheorem","statement":"Every prime number is odd","success?":false,"typecorrect_translations":[]},{"failed_translations":[{"args":"(n : ℤ)","name":"int.sum_four_squares","type":"∃ (a b c d : ℤ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : ℕ)","name":"nat.sum_four_squares_of_nat","type":"∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : ℕ)","name":"exists_sum_four_squares","type":"∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : ℕ)","name":"exists_four_squares_eq_sum","type":"∃ (a b c d : ℕ),a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : ℕ)","name":"nat.four_squares","type":"∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : ℕ)","name":"nat.sum_four_squares_of_nat","type":"∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : ℕ)","name":"nat.sum_four_squares_aux","type":"∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"","name":"nat.sum_four_squares'","type":" ∀ (n : ℕ), ∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\n| 0     "},{"args":"(n : ℕ)","name":"nat.four_squares","type":"∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : ℕ)","name":"nat.sum_four_squares","type":"∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"}],"prompt":"/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/ \n theorem fermat_42.exists_minimal{a b c : ℤ} (h : fermat_42 a b c):∃ (a0 b0 c0 : ℤ), fermat_42.minimal a0 b0 c0\n\n/-- **Formula for Pythagorean Triples** -/ \n theorem pythagorean_triple.classification{x y z : ℤ}:pythagorean_triple x y z ↔ ∃ (k m n : ℤ), (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧ (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2))\n\n/--  We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd and `c` positive. -/ \n theorem fermat_42.exists_pos_odd_minimal{a b c : ℤ} (h : fermat_42 a b c):∃ (a0 b0 c0 : ℤ), fermat_42.minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0\n\n/-- Expand the square -/ \n theorem norm_sub_sq_real{F : Type u_3} [inner_product_space ℝ F] {x y : F}:∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * has_inner.inner x y + ∥y∥ ^ 2\n\n/-- Expand the square -/ \n theorem norm_sub_sq{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E}:∥x - y∥ ^ 2 = ∥x∥ ^ 2 - 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ ^ 2\n\n/-- Expand the square -/ \n theorem norm_add_mul_self{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E}:∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ * ∥y∥\n\n/-- Expand the square -/ \n theorem norm_add_mul_self_real{F : Type u_3} [inner_product_space ℝ F] {x y : F}:∥x + y∥ * ∥x + y∥ = ∥x∥ * ∥x∥ + 2 * has_inner.inner x y + ∥y∥ * ∥y∥\n\n/-- Expand the square -/ \n theorem norm_sub_mul_self_real{F : Type u_3} [inner_product_space ℝ F] {x y : F}:∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ - 2 * has_inner.inner x y + ∥y∥ * ∥y∥\n\n/-- Expand the square -/ \n theorem norm_add_sq_real{F : Type u_3} [inner_product_space ℝ F] {x y : F}:∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * has_inner.inner x y + ∥y∥ ^ 2\n\n/-- Expand the square -/ \n theorem norm_sub_mul_self{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E}:∥x - y∥ * ∥x - y∥ = ∥x∥ * ∥x∥ - 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ * ∥y∥\n\n/-- Expand the square -/ \n theorem norm_add_sq{𝕜 : Type u_1} {E : Type u_2} [is_R_or_C 𝕜] [inner_product_space 𝕜 E] {x y : E}:∥x + y∥ ^ 2 = ∥x∥ ^ 2 + 2 * ⇑is_R_or_C.re (has_inner.inner x y) + ∥y∥ ^ 2\n\n/-- The sum of two squares is zero iff both elements are zero. -/ \n theorem mul_self_add_mul_self_eq_zero{α : Type u} [linear_ordered_ring α] {x y : α}:x * x + y * y = 0 ↔ x = 0 ∧ y = 0\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/ \n theorem nat.not_exists_sq{n m : ℕ} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)):¬∃ (t : ℕ), t * t = n\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/ \n theorem nat.prime.sq_add_sq{p : ℕ} [fact (nat.prime p)] (hp : p % 4 = 1):∃ (a b : ℕ), a ^ 2 + b ^ 2 = p\n\n/-- **Four squares theorem** -/ \n theorem nat.sum_four_squares(n : ℕ):∃ (a b c d : ℕ), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\n\n/-- Every natural number can be written as the sum of four squares -/\ntheorem","statement":"Every natural number can be written as the sum of four squares","success?":false,"typecorrect_translations":[]},{"failed_translations":[{"args":"{n m : ℕ} (h : odd n) (h1 : even m) ","name":"nat.odd_of_odd_add_even","type":" odd (n + m) "},{"args":"{m n : ℕ}","name":"nat.odd_add_even","type":"odd m → even n → odd (m + n)"},{"args":"{m n : ℕ} (h_odd : odd m) (h_even : even n) ","name":"add_odd_even","type":" odd (m + n) "},{"args":"(m n : ℕ) ","name":"nat.odd_add_even_iff_odd","type":" nat.odd (m + n) ↔ nat.odd m "},{"args":"{n m : ℕ} (hn : odd n) (hm : even m) ","name":"odd_add_even","type":" odd (n + m)"},{"args":"(n m : ℕ) (hn : nat.odd n) (hm : nat.even m) ","name":"nat.add_odd_even","type":" nat.odd (n + m) "},{"args":"{m n : ℕ} ","name":"add_odd_even_iff","type":" odd (m + n) ↔ odd m ∧ even n "},{"args":"(m n : ℕ)","name":"add_odd_add_even","type":" odd m → even n → odd (m + n)"},{"args":"{m n : ℕ}","name":"nat.odd_add_even","type":"odd m → even n → odd (m + n)"}],"prompt":"/-- To prove a property of a finite sum, it suffices to prove that the property is additive and holds on summands. -/ \n theorem finsum_mem_induction{α : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : α → M} {s : set α} (p : M → Prop) (hp₀ : p 0) (hp₁ : ∀ (x y : M), p x → p y → p (x + y)) (hp₂ : ∀ (x : α), x ∈ s → p (f x)):p (finsum (λ (i : α), finsum (λ (H : i ∈ s), f i)))\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/ \n theorem nat.dvd_add_self_left{m n : ℕ}:m ∣ m + n ↔ m ∣ n\n\n/-- If we can partition a sum into subsets that cancel out, then the whole sum cancels. -/ \n theorem finset.sum_cancels_of_partition_cancels{β : Type u} {α : Type v} {s : finset α} {f : α → β} [add_comm_monoid β] (R : setoid α) [decidable_rel setoid.r] (h : ∀ (x : α), x ∈ s → (finset.filter (λ (y : α), y ≈ x) s).sum (λ (a : α), f a) = 0):s.sum (λ (x : α), f x) = 0\n\n/--  Subtracting two points in the reverse order produces the negation of subtracting them. -/ \n theorem neg_vsub_eq_vsub_rev{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P):-(p1 -ᵥ p2) = p2 -ᵥ p1\n\n/-- The sum of two squares is zero iff both elements are zero. -/ \n theorem mul_self_add_mul_self_eq_zero{α : Type u} [linear_ordered_ring α] {x y : α}:x * x + y * y = 0 ↔ x = 0 ∧ y = 0\n\n/-- To prove a property of a finite sum, it suffices to prove that the property is additive and holds on the summands. -/ \n theorem finsum_induction{M : Type u_2} {α : Sort u_4} [add_comm_monoid M] {f : α → M} (p : M → Prop) (hp₀ : p 0) (hp₁ : ∀ (x y : M), p x → p y → p (x + y)) (hp₂ : ∀ (i : α), p (f i)):p (finsum (λ (i : α), f i))\n\n/-- The sum over the values of the quadratic character is zero when the characteristic is odd. -/ \n theorem char.quadratic_char_sum_zero{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ≠ 2):finset.univ.sum (λ (a : F), char.quadratic_char F a) = 0\n\n/-- To prove a property of a sum, it suffices to prove that the property is additive and holds on summands. -/ \n theorem finset.sum_induction{α : Type v} {s : finset α} {M : Type u_1} [add_comm_monoid M] (f : α → M) (p : M → Prop) (p_mul : ∀ (a b : M), p a → p b → p (a + b)) (p_one : p 0) (p_s : ∀ (x : α), x ∈ s → p (f x)):p (s.sum (λ (x : α), f x))\n\n/-- To prove a property of a sum, it suffices to prove that the property is additive and holds on summands. -/ \n theorem finset.sum_induction_nonempty{α : Type v} {s : finset α} {M : Type u_1} [add_comm_monoid M] (f : α → M) (p : M → Prop) (p_mul : ∀ (a b : M), p a → p b → p (a + b)) (hs_nonempty : s.nonempty) (p_s : ∀ (x : α), x ∈ s → p (f x)):p (s.sum (λ (x : α), f x))\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/ \n theorem bernoulli'_odd_eq_zero{n : ℕ} (h_odd : odd n) (hlt : 1 < n):bernoulli' n = 0\n\n/--  To show a property is true on the even parts, it suffices to show it is true on the scalars, closed under addition, and under left-multiplication by a pair of vectors. -/ \n theorem clifford_algebra.even_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 0 → Prop} (hr : ∀ (r : R), P (⇑(algebra_map R (clifford_algebra Q)) r) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 0} {hy : y ∈ clifford_algebra.even_odd Q 0}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 0}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 0):P x hx\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/ \n theorem nat.odd_mod_four_iff{n : ℕ}:n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/ \n theorem nat.even_pow{m n : ℕ}:even (m ^ n) ↔ even m ∧ n ≠ 0\n\n/--  To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors. -/ \n theorem clifford_algebra.odd_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q 1 → Prop} (hι : ∀ (v : M), P (⇑(clifford_algebra.ι Q) v) _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1} {hy : y ∈ clifford_algebra.even_odd Q 1}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q 1}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q 1):P x hx\n\n/--  To show a property is true on the even or odd part, it suffices to show it is true on the scalars or vectors (respectively), closed under addition, and under left-multiplication by a pair of vectors. -/ \n theorem clifford_algebra.even_odd_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Π (x : clifford_algebra Q), x ∈ clifford_algebra.even_odd Q n → Prop} (hr : ∀ (v : clifford_algebra Q) (h : v ∈ (clifford_algebra.ι Q).range ^ n.val), P v _) (hadd : ∀ {x y : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n} {hy : y ∈ clifford_algebra.even_odd Q n}, P x hx → P y hy → P (x + y) _) (hιι_mul : ∀ (m₁ m₂ : M) {x : clifford_algebra Q} {hx : x ∈ clifford_algebra.even_odd Q n}, P x hx → P (⇑(clifford_algebra.ι Q) m₁ * ⇑(clifford_algebra.ι Q) m₂ * x) _) (x : clifford_algebra Q) (hx : x ∈ clifford_algebra.even_odd Q n):P x hx\n\n/-- The sum of an odd and an even number is odd. -/\ntheorem","statement":"The sum of an odd and an even number is odd.","success?":true,"typecorrect_translations":[{"args":"{m n : ℕ} (h_odd : m % 2 = 1) (h_even : n % 2 = 0)","name":"nat.odd_add_of_odd_or_even","type":"(m + n) % 2 = 1"}]}]