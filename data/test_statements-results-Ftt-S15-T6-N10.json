[{"failed_translations":[{"args":"{p : â„•} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : â„•} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : â„•} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : â„•} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : â„•} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : â„•} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p"},{"args":"{p : â„•} (hp : nat.prime p)","name":"nat.prime.odd","type":"odd p"},{"args":"{p : â„•} (hp : nat.prime p)","name":"nat.prime.odd","type":"odd p "},{"args":"{p : â„•} [fact (nat.prime p)]","name":"nat.prime_odd","type":" odd p"},{"args":"{p : â„•} [fact (nat.prime p)]","name":"nat.prime.odd","type":" odd p"}],"prompt":"/-- If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`. -/ \n theorem nat.eq_prime_pow_of_dvd_least_prime_pow{a p k : â„•} (pp : nat.prime p) (hâ‚ : Â¬a âˆ£ p ^ k) (hâ‚‚ : a âˆ£ p ^ (k + 1)):a = p ^ (k + 1)\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/ \n theorem is_prime_pow_iff_pow_succ{R : Type u_1} [comm_monoid_with_zero R] (n : R):is_prime_pow n â†” âˆƒ (p : R) (k : â„•), prime p âˆ§ p ^ (k + 1) = n\n\n/-- In a finite field of odd characteristic, not every element is a square. -/ \n theorem finite_field.exists_nonsquare{F : Type u_3} [field F] [fintype F] (hF : ring_char F â‰  2):âˆƒ (a : F), Â¬is_square a\n\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/ \n theorem nat.mem_factors_mul_right{p a b : â„•} (hpb : p âˆˆ b.factors) (ha : a â‰  0):p âˆˆ (a * b).factors\n\n/-- The only divisors of prime powers are prime powers. -/ \n theorem associates.eq_pow_find_of_dvd_irreducible_pow{Î± : Type u_1} [cancel_comm_monoid_with_zero Î±] [unique_factorization_monoid Î±] {a p : associates Î±} (hp : irreducible p) [Î  (n : â„•), decidable (a âˆ£ p ^ n)] {n : â„•} (h : a âˆ£ p ^ n):a = p ^ nat.find _\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/ \n theorem is_prime_pow_iff_unique_prime_dvd{n : â„•}:is_prime_pow n â†” âˆƒ! (p : â„•), nat.prime p âˆ§ p âˆ£ n\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/ \n theorem bernoulli'_odd_eq_zero{n : â„•} (h_odd : odd n) (hlt : 1 < n):bernoulli' n = 0\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/ \n theorem nat.mem_factors_mul_left{p a b : â„•} (hpa : p âˆˆ a.factors) (hb : b â‰  0):p âˆˆ (a * b).factors\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/ \n theorem nat.even_pow{m n : â„•}:even (m ^ n) â†” even m âˆ§ n â‰  0\n\n/-- Every nonzero natural number has a unique prime factorization -/ \n theorem nat.factorization_inj:set.inj_on nat.factorization {x : â„• | x â‰  0}\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/ \n theorem zmod.wilsons_lemma(p : â„•) [fact (nat.prime p)]:â†‘((p - 1).factorial) = -1\n\n/-- The only prime factor of prime `p` is `p` itself, with multiplicity `1` -/ \n theorem nat.prime.factorization{p : â„•} (hp : nat.prime p):p.factorization = finsupp.single p 1\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/ \n theorem nat.factorization_eq_zero_iff(n : â„•):n.factorization = 0 â†” n = 0 âˆ¨ n = 1\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/ \n theorem nat.odd_mod_four_iff{n : â„•}:n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p â‰  2`. -/ \n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : â„•} [fact (nat.prime p)]:p % 2 = 1 â†” p â‰  2\n\n/-- Every prime number is odd -/\ntheorem","statement":"Every prime number is odd","success?":false,"typecorrect_translations":[]},{"failed_translations":[{"args":"(n : â„¤)","name":"int.sum_four_squares","type":"âˆƒ (a b c d : â„¤), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : â„•)","name":"nat.sum_four_squares_of_nat","type":"âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : â„•)","name":"exists_sum_four_squares","type":"âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : â„•)","name":"exists_four_squares_eq_sum","type":"âˆƒ (a b c d : â„•),a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : â„•)","name":"nat.four_squares","type":"âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : â„•)","name":"nat.sum_four_squares_of_nat","type":"âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : â„•)","name":"nat.sum_four_squares_aux","type":"âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"","name":"nat.sum_four_squares'","type":" âˆ€ (n : â„•), âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\n| 0     "},{"args":"(n : â„•)","name":"nat.four_squares","type":"âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"},{"args":"(n : â„•)","name":"nat.sum_four_squares","type":"âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n"}],"prompt":"/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/ \n theorem fermat_42.exists_minimal{a b c : â„¤} (h : fermat_42 a b c):âˆƒ (a0 b0 c0 : â„¤), fermat_42.minimal a0 b0 c0\n\n/-- **Formula for Pythagorean Triples** -/ \n theorem pythagorean_triple.classification{x y z : â„¤}:pythagorean_triple x y z â†” âˆƒ (k m n : â„¤), (x = k * (m ^ 2 - n ^ 2) âˆ§ y = k * (2 * m * n) âˆ¨ x = k * (2 * m * n) âˆ§ y = k * (m ^ 2 - n ^ 2)) âˆ§ (z = k * (m ^ 2 + n ^ 2) âˆ¨ z = -k * (m ^ 2 + n ^ 2))\n\n/--  We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd and `c` positive. -/ \n theorem fermat_42.exists_pos_odd_minimal{a b c : â„¤} (h : fermat_42 a b c):âˆƒ (a0 b0 c0 : â„¤), fermat_42.minimal a0 b0 c0 âˆ§ a0 % 2 = 1 âˆ§ 0 < c0\n\n/-- Expand the square -/ \n theorem norm_sub_sq_real{F : Type u_3} [inner_product_space â„ F] {x y : F}:âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2\n\n/-- Expand the square -/ \n theorem norm_sub_sq{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] {x y : E}:âˆ¥x - yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2\n\n/-- Expand the square -/ \n theorem norm_add_mul_self{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] {x y : E}:âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥\n\n/-- Expand the square -/ \n theorem norm_add_mul_self_real{F : Type u_3} [inner_product_space â„ F] {x y : F}:âˆ¥x + yâˆ¥ * âˆ¥x + yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ + 2 * has_inner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥\n\n/-- Expand the square -/ \n theorem norm_sub_mul_self_real{F : Type u_3} [inner_product_space â„ F] {x y : F}:âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * has_inner.inner x y + âˆ¥yâˆ¥ * âˆ¥yâˆ¥\n\n/-- Expand the square -/ \n theorem norm_add_sq_real{F : Type u_3} [inner_product_space â„ F] {x y : F}:âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * has_inner.inner x y + âˆ¥yâˆ¥ ^ 2\n\n/-- Expand the square -/ \n theorem norm_sub_mul_self{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] {x y : E}:âˆ¥x - yâˆ¥ * âˆ¥x - yâˆ¥ = âˆ¥xâˆ¥ * âˆ¥xâˆ¥ - 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ * âˆ¥yâˆ¥\n\n/-- Expand the square -/ \n theorem norm_add_sq{ð•œ : Type u_1} {E : Type u_2} [is_R_or_C ð•œ] [inner_product_space ð•œ E] {x y : E}:âˆ¥x + yâˆ¥ ^ 2 = âˆ¥xâˆ¥ ^ 2 + 2 * â‡‘is_R_or_C.re (has_inner.inner x y) + âˆ¥yâˆ¥ ^ 2\n\n/-- The sum of two squares is zero iff both elements are zero. -/ \n theorem mul_self_add_mul_self_eq_zero{Î± : Type u} [linear_ordered_ring Î±] {x y : Î±}:x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\n\n/-- There are no perfect squares strictly between mÂ² and (m+1)Â² -/ \n theorem nat.not_exists_sq{n m : â„•} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)):Â¬âˆƒ (t : â„•), t * t = n\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/ \n theorem nat.prime.sq_add_sq{p : â„•} [fact (nat.prime p)] (hp : p % 4 = 1):âˆƒ (a b : â„•), a ^ 2 + b ^ 2 = p\n\n/-- **Four squares theorem** -/ \n theorem nat.sum_four_squares(n : â„•):âˆƒ (a b c d : â„•), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\n\n/-- Every natural number can be written as the sum of four squares -/\ntheorem","statement":"Every natural number can be written as the sum of four squares","success?":false,"typecorrect_translations":[]},{"failed_translations":[{"args":"{n m : â„•} (h : odd n) (h1 : even m) ","name":"nat.odd_of_odd_add_even","type":" odd (n + m) "},{"args":"{m n : â„•}","name":"nat.odd_add_even","type":"odd m â†’ even n â†’ odd (m + n)"},{"args":"{m n : â„•} (h_odd : odd m) (h_even : even n) ","name":"add_odd_even","type":" odd (m + n) "},{"args":"(m n : â„•) ","name":"nat.odd_add_even_iff_odd","type":" nat.odd (m + n) â†” nat.odd m "},{"args":"{n m : â„•} (hn : odd n) (hm : even m) ","name":"odd_add_even","type":" odd (n + m)"},{"args":"(n m : â„•) (hn : nat.odd n) (hm : nat.even m) ","name":"nat.add_odd_even","type":" nat.odd (n + m) "},{"args":"{m n : â„•} ","name":"add_odd_even_iff","type":" odd (m + n) â†” odd m âˆ§ even n "},{"args":"(m n : â„•)","name":"add_odd_add_even","type":" odd m â†’ even n â†’ odd (m + n)"},{"args":"{m n : â„•}","name":"nat.odd_add_even","type":"odd m â†’ even n â†’ odd (m + n)"}],"prompt":"/-- To prove a property of a finite sum, it suffices to prove that the property is additive and holds on summands. -/ \n theorem finsum_mem_induction{Î± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Î± â†’ M} {s : set Î±} (p : M â†’ Prop) (hpâ‚€ : p 0) (hpâ‚ : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (hpâ‚‚ : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)):p (finsum (Î» (i : Î±), finsum (Î» (H : i âˆˆ s), f i)))\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/ \n theorem nat.dvd_add_self_left{m n : â„•}:m âˆ£ m + n â†” m âˆ£ n\n\n/-- If we can partition a sum into subsets that cancel out, then the whole sum cancels. -/ \n theorem finset.sum_cancels_of_partition_cancels{Î² : Type u} {Î± : Type v} {s : finset Î±} {f : Î± â†’ Î²} [add_comm_monoid Î²] (R : setoid Î±) [decidable_rel setoid.r] (h : âˆ€ (x : Î±), x âˆˆ s â†’ (finset.filter (Î» (y : Î±), y â‰ˆ x) s).sum (Î» (a : Î±), f a) = 0):s.sum (Î» (x : Î±), f x) = 0\n\n/--  Subtracting two points in the reverse order produces the negation of subtracting them. -/ \n theorem neg_vsub_eq_vsub_rev{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P):-(p1 -áµ¥ p2) = p2 -áµ¥ p1\n\n/-- The sum of two squares is zero iff both elements are zero. -/ \n theorem mul_self_add_mul_self_eq_zero{Î± : Type u} [linear_ordered_ring Î±] {x y : Î±}:x * x + y * y = 0 â†” x = 0 âˆ§ y = 0\n\n/-- To prove a property of a finite sum, it suffices to prove that the property is additive and holds on the summands. -/ \n theorem finsum_induction{M : Type u_2} {Î± : Sort u_4} [add_comm_monoid M] {f : Î± â†’ M} (p : M â†’ Prop) (hpâ‚€ : p 0) (hpâ‚ : âˆ€ (x y : M), p x â†’ p y â†’ p (x + y)) (hpâ‚‚ : âˆ€ (i : Î±), p (f i)):p (finsum (Î» (i : Î±), f i))\n\n/-- The sum over the values of the quadratic character is zero when the characteristic is odd. -/ \n theorem char.quadratic_char_sum_zero{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F â‰  2):finset.univ.sum (Î» (a : F), char.quadratic_char F a) = 0\n\n/-- To prove a property of a sum, it suffices to prove that the property is additive and holds on summands. -/ \n theorem finset.sum_induction{Î± : Type v} {s : finset Î±} {M : Type u_1} [add_comm_monoid M] (f : Î± â†’ M) (p : M â†’ Prop) (p_mul : âˆ€ (a b : M), p a â†’ p b â†’ p (a + b)) (p_one : p 0) (p_s : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)):p (s.sum (Î» (x : Î±), f x))\n\n/-- To prove a property of a sum, it suffices to prove that the property is additive and holds on summands. -/ \n theorem finset.sum_induction_nonempty{Î± : Type v} {s : finset Î±} {M : Type u_1} [add_comm_monoid M] (f : Î± â†’ M) (p : M â†’ Prop) (p_mul : âˆ€ (a b : M), p a â†’ p b â†’ p (a + b)) (hs_nonempty : s.nonempty) (p_s : âˆ€ (x : Î±), x âˆˆ s â†’ p (f x)):p (s.sum (Î» (x : Î±), f x))\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/ \n theorem bernoulli'_odd_eq_zero{n : â„•} (h_odd : odd n) (hlt : 1 < n):bernoulli' n = 0\n\n/--  To show a property is true on the even parts, it suffices to show it is true on the scalars, closed under addition, and under left-multiplication by a pair of vectors. -/ \n theorem clifford_algebra.even_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Î  (x : clifford_algebra Q), x âˆˆ clifford_algebra.even_odd Q 0 â†’ Prop} (hr : âˆ€ (r : R), P (â‡‘(algebra_map R (clifford_algebra Q)) r) _) (hadd : âˆ€ {x y : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q 0} {hy : y âˆˆ clifford_algebra.even_odd Q 0}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_mul : âˆ€ (mâ‚ mâ‚‚ : M) {x : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q 0}, P x hx â†’ P (â‡‘(clifford_algebra.Î¹ Q) mâ‚ * â‡‘(clifford_algebra.Î¹ Q) mâ‚‚ * x) _) (x : clifford_algebra Q) (hx : x âˆˆ clifford_algebra.even_odd Q 0):P x hx\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/ \n theorem nat.odd_mod_four_iff{n : â„•}:n % 2 = 1 â†” n % 4 = 1 âˆ¨ n % 4 = 3\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/ \n theorem nat.even_pow{m n : â„•}:even (m ^ n) â†” even m âˆ§ n â‰  0\n\n/--  To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors. -/ \n theorem clifford_algebra.odd_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Î  (x : clifford_algebra Q), x âˆˆ clifford_algebra.even_odd Q 1 â†’ Prop} (hÎ¹ : âˆ€ (v : M), P (â‡‘(clifford_algebra.Î¹ Q) v) _) (hadd : âˆ€ {x y : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q 1} {hy : y âˆˆ clifford_algebra.even_odd Q 1}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_mul : âˆ€ (mâ‚ mâ‚‚ : M) {x : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q 1}, P x hx â†’ P (â‡‘(clifford_algebra.Î¹ Q) mâ‚ * â‡‘(clifford_algebra.Î¹ Q) mâ‚‚ * x) _) (x : clifford_algebra Q) (hx : x âˆˆ clifford_algebra.even_odd Q 1):P x hx\n\n/--  To show a property is true on the even or odd part, it suffices to show it is true on the scalars or vectors (respectively), closed under addition, and under left-multiplication by a pair of vectors. -/ \n theorem clifford_algebra.even_odd_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Î  (x : clifford_algebra Q), x âˆˆ clifford_algebra.even_odd Q n â†’ Prop} (hr : âˆ€ (v : clifford_algebra Q) (h : v âˆˆ (clifford_algebra.Î¹ Q).range ^ n.val), P v _) (hadd : âˆ€ {x y : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q n} {hy : y âˆˆ clifford_algebra.even_odd Q n}, P x hx â†’ P y hy â†’ P (x + y) _) (hÎ¹Î¹_mul : âˆ€ (mâ‚ mâ‚‚ : M) {x : clifford_algebra Q} {hx : x âˆˆ clifford_algebra.even_odd Q n}, P x hx â†’ P (â‡‘(clifford_algebra.Î¹ Q) mâ‚ * â‡‘(clifford_algebra.Î¹ Q) mâ‚‚ * x) _) (x : clifford_algebra Q) (hx : x âˆˆ clifford_algebra.even_odd Q n):P x hx\n\n/-- The sum of an odd and an even number is odd. -/\ntheorem","statement":"The sum of an odd and an even number is odd.","success?":true,"typecorrect_translations":[{"args":"{m n : â„•} (h_odd : m % 2 = 1) (h_even : n % 2 = 0)","name":"nat.odd_add_of_odd_or_even","type":"(m + n) % 2 = 1"}]}]