[{"failed_translations":[{"args":"(p : ‚Ñï) (hp : nat.prime p) ","name":"nat.prime.odd","type":" nat.odd p "},{"args":"{p : ‚Ñï} (hp : nat.prime p) ","name":"nat.prime.odd","type":" nat.odd p "},{"args":"{p:‚Ñï} [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p\n\n"},{"args":"(p : ‚Ñï) [fact (nat.prime p)]","name":"nat.prime.odd","type":"odd p\n"},{"args":"{p : ‚Ñï} [fact (nat.prime p)] ","name":"nat.prime.odd","type":" odd p\n\n"},{"args":"{p : ‚Ñï}","name":"nat.prime.odd","type":" nat.prime p ‚Üí odd p\n\n"},{"args":"","name":"nat.prime.odd","type":" ‚àÄ (p : ‚Ñï), nat.prime p ‚Üí odd p\n\n"},{"args":"{p : ‚Ñï} [fact (nat.prime p)] ","name":"nat.prime.odd","type":" p % 2 = 1\n\n"},{"args":"{p : ‚Ñï} (h : nat.prime p) ","name":"nat.prime.odd","type":" nat.odd p "}],"prompt":"/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ‚â† 2`. -/ \n theorem nat.prime.mod_two_eq_one_iff_ne_two{p : ‚Ñï} [fact (nat.prime p)]:p % 2 = 1 ‚Üî p ‚â† 2\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/ \n theorem nat.odd_mod_four_iff{n : ‚Ñï}:n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/ \n theorem nat.factorization_eq_zero_iff(n : ‚Ñï):n.factorization = 0 ‚Üî n = 0 ‚à® n = 1\n\n/-- The only prime factor of prime `p` is `p` itself, with multiplicity `1` -/ \n theorem nat.prime.factorization{p : ‚Ñï} (hp : nat.prime p):p.factorization = finsupp.single p 1\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/ \n theorem zmod.wilsons_lemma(p : ‚Ñï) [fact (nat.prime p)]:‚Üë((p - 1).factorial) = -1\n\n/-- Every nonzero natural number has a unique prime factorization -/ \n theorem nat.factorization_inj:set.inj_on nat.factorization {x : ‚Ñï | x ‚â† 0}\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/ \n theorem nat.even_pow{m n : ‚Ñï}:even (m ^ n) ‚Üî even m ‚àß n ‚â† 0\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/ \n theorem nat.mem_factors_mul_left{p a b : ‚Ñï} (hpa : p ‚àà a.factors) (hb : b ‚â† 0):p ‚àà (a * b).factors\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/ \n theorem bernoulli'_odd_eq_zero{n : ‚Ñï} (h_odd : odd n) (hlt : 1 < n):bernoulli' n = 0\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime dividing it. -/ \n theorem is_prime_pow_iff_unique_prime_dvd{n : ‚Ñï}:is_prime_pow n ‚Üî ‚àÉ! (p : ‚Ñï), nat.prime p ‚àß p ‚à£ n\n\n/-- The only divisors of prime powers are prime powers. -/ \n theorem associates.eq_pow_find_of_dvd_irreducible_pow{Œ± : Type u_1} [cancel_comm_monoid_with_zero Œ±] [unique_factorization_monoid Œ±] {a p : associates Œ±} (hp : irreducible p) [Œ† (n : ‚Ñï), decidable (a ‚à£ p ^ n)] {n : ‚Ñï} (h : a ‚à£ p ^ n):a = p ^ nat.find _\n\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/ \n theorem nat.mem_factors_mul_right{p a b : ‚Ñï} (hpb : p ‚àà b.factors) (ha : a ‚â† 0):p ‚àà (a * b).factors\n\n/-- In a finite field of odd characteristic, not every element is a square. -/ \n theorem finite_field.exists_nonsquare{F : Type u_3} [field F] [fintype F] (hF : ring_char F ‚â† 2):‚àÉ (a : F), ¬¨is_square a\n\n/--  An equivalent definition for prime powers: `n` is a prime power iff there is a prime `p` and a natural `k` such that `n` can be written as `p^(k+1)`. -/ \n theorem is_prime_pow_iff_pow_succ{R : Type u_1} [comm_monoid_with_zero R] (n : R):is_prime_pow n ‚Üî ‚àÉ (p : R) (k : ‚Ñï), prime p ‚àß p ^ (k + 1) = n\n\n/-- If `p` is prime, and `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)` then `a = p^(k+1)`. -/ \n theorem nat.eq_prime_pow_of_dvd_least_prime_pow{a p k : ‚Ñï} (pp : nat.prime p) (h‚ÇÅ : ¬¨a ‚à£ p ^ k) (h‚ÇÇ : a ‚à£ p ^ (k + 1)):a = p ^ (k + 1)\n\n/-- Every prime number is odd -/\ntheorem","statement":"Every prime number is odd","success?":true,"typecorrect_translations":[{"args":"","name":"nat.prime.odd{p","type":" ‚Ñï} [fact (nat.prime p)]:odd p\n\n"}]},{"failed_translations":[{"args":"(n: ‚Ñï)","name":"four_squares","type":" ‚àÉ (a b c d: ‚Ñï), a^2 + b^2 + c^2 + d^2 = n "},{"args":"(n : ‚Ñï) ","name":"sum_four_squares_nat","type":" ‚àÉ (a b c d : ‚Ñï), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n "},{"args":"(n : ‚Ñï) ","name":"sum_four_squares","type":" ‚àÉ a b c d, a^2 + b^2 + c^2 + d^2 = n "}],"prompt":"/-- **Four squares theorem** -/ \n theorem nat.sum_four_squares(n : ‚Ñï):‚àÉ (a b c d : ‚Ñï), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\n\n/--  **Fermat's theorem on the sum of two squares**. Every prime congruent to 1 mod 4 is the sum of two squares. Also known as **Fermat's Christmas theorem**. -/ \n theorem nat.prime.sq_add_sq{p : ‚Ñï} [fact (nat.prime p)] (hp : p % 4 = 1):‚àÉ (a b : ‚Ñï), a ^ 2 + b ^ 2 = p\n\n/-- There are no perfect squares strictly between m¬≤ and (m+1)¬≤ -/ \n theorem nat.not_exists_sq{n m : ‚Ñï} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)):¬¨‚àÉ (t : ‚Ñï), t * t = n\n\n/-- The sum of two squares is zero iff both elements are zero. -/ \n theorem mul_self_add_mul_self_eq_zero{Œ± : Type u} [linear_ordered_ring Œ±] {x y : Œ±}:x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0\n\n/-- Expand the square -/ \n theorem norm_add_sq{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {x y : E}:‚à•x + y‚à• ^ 2 = ‚à•x‚à• ^ 2 + 2 * ‚áëis_R_or_C.re (has_inner.inner x y) + ‚à•y‚à• ^ 2\n\n/-- Expand the square -/ \n theorem norm_sub_mul_self{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {x y : E}:‚à•x - y‚à• * ‚à•x - y‚à• = ‚à•x‚à• * ‚à•x‚à• - 2 * ‚áëis_R_or_C.re (has_inner.inner x y) + ‚à•y‚à• * ‚à•y‚à•\n\n/-- Expand the square -/ \n theorem norm_add_sq_real{F : Type u_3} [inner_product_space ‚Ñù F] {x y : F}:‚à•x + y‚à• ^ 2 = ‚à•x‚à• ^ 2 + 2 * has_inner.inner x y + ‚à•y‚à• ^ 2\n\n/-- Expand the square -/ \n theorem norm_sub_mul_self_real{F : Type u_3} [inner_product_space ‚Ñù F] {x y : F}:‚à•x - y‚à• * ‚à•x - y‚à• = ‚à•x‚à• * ‚à•x‚à• - 2 * has_inner.inner x y + ‚à•y‚à• * ‚à•y‚à•\n\n/-- Expand the square -/ \n theorem norm_add_mul_self_real{F : Type u_3} [inner_product_space ‚Ñù F] {x y : F}:‚à•x + y‚à• * ‚à•x + y‚à• = ‚à•x‚à• * ‚à•x‚à• + 2 * has_inner.inner x y + ‚à•y‚à• * ‚à•y‚à•\n\n/-- Expand the square -/ \n theorem norm_add_mul_self{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {x y : E}:‚à•x + y‚à• * ‚à•x + y‚à• = ‚à•x‚à• * ‚à•x‚à• + 2 * ‚áëis_R_or_C.re (has_inner.inner x y) + ‚à•y‚à• * ‚à•y‚à•\n\n/-- Expand the square -/ \n theorem norm_sub_sq{ùïú : Type u_1} {E : Type u_2} [is_R_or_C ùïú] [inner_product_space ùïú E] {x y : E}:‚à•x - y‚à• ^ 2 = ‚à•x‚à• ^ 2 - 2 * ‚áëis_R_or_C.re (has_inner.inner x y) + ‚à•y‚à• ^ 2\n\n/-- Expand the square -/ \n theorem norm_sub_sq_real{F : Type u_3} [inner_product_space ‚Ñù F] {x y : F}:‚à•x - y‚à• ^ 2 = ‚à•x‚à• ^ 2 - 2 * has_inner.inner x y + ‚à•y‚à• ^ 2\n\n/--  We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd and `c` positive. -/ \n theorem fermat_42.exists_pos_odd_minimal{a b c : ‚Ñ§} (h : fermat_42 a b c):‚àÉ (a0 b0 c0 : ‚Ñ§), fermat_42.minimal a0 b0 c0 ‚àß a0 % 2 = 1 ‚àß 0 < c0\n\n/-- **Formula for Pythagorean Triples** -/ \n theorem pythagorean_triple.classification{x y z : ‚Ñ§}:pythagorean_triple x y z ‚Üî ‚àÉ (k m n : ‚Ñ§), (x = k * (m ^ 2 - n ^ 2) ‚àß y = k * (2 * m * n) ‚à® x = k * (2 * m * n) ‚àß y = k * (m ^ 2 - n ^ 2)) ‚àß (z = k * (m ^ 2 + n ^ 2) ‚à® z = -k * (m ^ 2 + n ^ 2))\n\n/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/ \n theorem fermat_42.exists_minimal{a b c : ‚Ñ§} (h : fermat_42 a b c):‚àÉ (a0 b0 c0 : ‚Ñ§), fermat_42.minimal a0 b0 c0\n\n/-- Every natural number can be written as the sum of four squares -/\ntheorem","statement":"Every natural number can be written as the sum of four squares","success?":true,"typecorrect_translations":[{"args":"","name":"nat.sum_four_squares(n","type":" ‚Ñï):‚àÉ (a b c d : ‚Ñï), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\n"},{"args":"{n : ‚Ñï} ","name":"nat.sq_sum_four_squares","type":" ‚àÉ (a b c d : ‚Ñï), a*a + b*b + c*c + d*d = n "},{"args":"","name":"nat.sum_four_squares_nat(n","type":" ‚Ñï) : ‚àÉ (a b c d : ‚Ñï), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n "},{"args":"","name":"nat.exists_sum_four_squares(n","type":" ‚Ñï):‚àÉ (a b c d : ‚Ñï), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\n\n"},{"args":"","name":"sum_four_squares(n","type":" ‚Ñï):‚àÉ (a b c d : ‚Ñï), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n "},{"args":"(n : ‚Ñï)","name":"nat.sum_four_sq","type":"‚àÉ (a b c d : ‚Ñï), a * a + b * b + c * c + d * d = n\n\n"},{"args":"","name":"nat.exists_four_squares(n","type":" ‚Ñï):‚àÉ (a b c d : ‚Ñï), a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\n\n"}]},{"failed_translations":[{"args":"{m n : ‚Ñï}","name":"nat.add_odd_even","type":"odd m ‚Üí even n ‚Üí odd (m + n)\n\n"},{"args":"(m n : ‚Ñï) (h_odd : odd m) (h_even : even n)","name":"add_odd_even","type":"odd (m + n)\n\n"},{"args":"(m n : ‚Ñï) ","name":"odd_add_even","type":" odd m ‚Üí even n ‚Üí odd (m + n)\n\n"},{"args":"{n m : ‚Ñï} (hn : odd n) (hm : even m) ","name":"odd_add_even","type":" odd (n + m)\n\n"},{"args":"{m n : ‚Ñï} ","name":"even_add_odd_of_odd_of_even","type":" odd m ‚Üí even n ‚Üí odd (m + n)\n\n"},{"args":"{n m : ‚Ñï} (h_odd : odd n) (h_even : even m) ","name":"nat.odd_add_of_odd_or_even","type":" odd (n + m) "}],"prompt":"/--  To show a property is true on the even or odd part, it suffices to show it is true on the scalars or vectors (respectively), closed under addition, and under left-multiplication by a pair of vectors. -/ \n theorem clifford_algebra.even_odd_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) (n : zmod 2) {P : Œ† (x : clifford_algebra Q), x ‚àà clifford_algebra.even_odd Q n ‚Üí Prop} (hr : ‚àÄ (v : clifford_algebra Q) (h : v ‚àà (clifford_algebra.Œπ Q).range ^ n.val), P v _) (hadd : ‚àÄ {x y : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q n} {hy : y ‚àà clifford_algebra.even_odd Q n}, P x hx ‚Üí P y hy ‚Üí P (x + y) _) (hŒπŒπ_mul : ‚àÄ (m‚ÇÅ m‚ÇÇ : M) {x : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q n}, P x hx ‚Üí P (‚áë(clifford_algebra.Œπ Q) m‚ÇÅ * ‚áë(clifford_algebra.Œπ Q) m‚ÇÇ * x) _) (x : clifford_algebra Q) (hx : x ‚àà clifford_algebra.even_odd Q n):P x hx\n\n/--  To show a property is true on the odd parts, it suffices to show it is true on the vectors, closed under addition, and under left-multiplication by a pair of vectors. -/ \n theorem clifford_algebra.odd_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Œ† (x : clifford_algebra Q), x ‚àà clifford_algebra.even_odd Q 1 ‚Üí Prop} (hŒπ : ‚àÄ (v : M), P (‚áë(clifford_algebra.Œπ Q) v) _) (hadd : ‚àÄ {x y : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q 1} {hy : y ‚àà clifford_algebra.even_odd Q 1}, P x hx ‚Üí P y hy ‚Üí P (x + y) _) (hŒπŒπ_mul : ‚àÄ (m‚ÇÅ m‚ÇÇ : M) {x : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q 1}, P x hx ‚Üí P (‚áë(clifford_algebra.Œπ Q) m‚ÇÅ * ‚áë(clifford_algebra.Œπ Q) m‚ÇÇ * x) _) (x : clifford_algebra Q) (hx : x ‚àà clifford_algebra.even_odd Q 1):P x hx\n\n/--  If `m` and `n` are natural numbers, then the natural number `m^n` is even if and only if `m` is even and `n` is positive. -/ \n theorem nat.even_pow{m n : ‚Ñï}:even (m ^ n) ‚Üî even m ‚àß n ‚â† 0\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/ \n theorem nat.odd_mod_four_iff{n : ‚Ñï}:n % 2 = 1 ‚Üî n % 4 = 1 ‚à® n % 4 = 3\n\n/--  To show a property is true on the even parts, it suffices to show it is true on the scalars, closed under addition, and under left-multiplication by a pair of vectors. -/ \n theorem clifford_algebra.even_induction{R : Type u_1} {M : Type u_2} [comm_ring R] [add_comm_group M] [module R M] (Q : quadratic_form R M) {P : Œ† (x : clifford_algebra Q), x ‚àà clifford_algebra.even_odd Q 0 ‚Üí Prop} (hr : ‚àÄ (r : R), P (‚áë(algebra_map R (clifford_algebra Q)) r) _) (hadd : ‚àÄ {x y : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q 0} {hy : y ‚àà clifford_algebra.even_odd Q 0}, P x hx ‚Üí P y hy ‚Üí P (x + y) _) (hŒπŒπ_mul : ‚àÄ (m‚ÇÅ m‚ÇÇ : M) {x : clifford_algebra Q} {hx : x ‚àà clifford_algebra.even_odd Q 0}, P x hx ‚Üí P (‚áë(clifford_algebra.Œπ Q) m‚ÇÅ * ‚áë(clifford_algebra.Œπ Q) m‚ÇÇ * x) _) (x : clifford_algebra Q) (hx : x ‚àà clifford_algebra.even_odd Q 0):P x hx\n\n/-- Odd Bernoulli numbers (greater than 1) are zero. -/ \n theorem bernoulli'_odd_eq_zero{n : ‚Ñï} (h_odd : odd n) (hlt : 1 < n):bernoulli' n = 0\n\n/-- To prove a property of a sum, it suffices to prove that the property is additive and holds on summands. -/ \n theorem finset.sum_induction_nonempty{Œ± : Type v} {s : finset Œ±} {M : Type u_1} [add_comm_monoid M] (f : Œ± ‚Üí M) (p : M ‚Üí Prop) (p_mul : ‚àÄ (a b : M), p a ‚Üí p b ‚Üí p (a + b)) (hs_nonempty : s.nonempty) (p_s : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p (f x)):p (s.sum (Œª (x : Œ±), f x))\n\n/-- To prove a property of a sum, it suffices to prove that the property is additive and holds on summands. -/ \n theorem finset.sum_induction{Œ± : Type v} {s : finset Œ±} {M : Type u_1} [add_comm_monoid M] (f : Œ± ‚Üí M) (p : M ‚Üí Prop) (p_mul : ‚àÄ (a b : M), p a ‚Üí p b ‚Üí p (a + b)) (p_one : p 0) (p_s : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p (f x)):p (s.sum (Œª (x : Œ±), f x))\n\n/-- The sum over the values of the quadratic character is zero when the characteristic is odd. -/ \n theorem char.quadratic_char_sum_zero{F : Type u_1} [field F] [fintype F] [decidable_eq F] (hF : ring_char F ‚â† 2):finset.univ.sum (Œª (a : F), char.quadratic_char F a) = 0\n\n/-- To prove a property of a finite sum, it suffices to prove that the property is additive and holds on the summands. -/ \n theorem finsum_induction{M : Type u_2} {Œ± : Sort u_4} [add_comm_monoid M] {f : Œ± ‚Üí M} (p : M ‚Üí Prop) (hp‚ÇÄ : p 0) (hp‚ÇÅ : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) (hp‚ÇÇ : ‚àÄ (i : Œ±), p (f i)):p (finsum (Œª (i : Œ±), f i))\n\n/-- The sum of two squares is zero iff both elements are zero. -/ \n theorem mul_self_add_mul_self_eq_zero{Œ± : Type u} [linear_ordered_ring Œ±] {x y : Œ±}:x * x + y * y = 0 ‚Üî x = 0 ‚àß y = 0\n\n/--  Subtracting two points in the reverse order produces the negation of subtracting them. -/ \n theorem neg_vsub_eq_vsub_rev{G : Type u_1} {P : Type u_2} [add_group G] [T : add_torsor G P] (p1 p2 : P):-(p1 -·µ• p2) = p2 -·µ• p1\n\n/-- If we can partition a sum into subsets that cancel out, then the whole sum cancels. -/ \n theorem finset.sum_cancels_of_partition_cancels{Œ≤ : Type u} {Œ± : Type v} {s : finset Œ±} {f : Œ± ‚Üí Œ≤} [add_comm_monoid Œ≤] (R : setoid Œ±) [decidable_rel setoid.r] (h : ‚àÄ (x : Œ±), x ‚àà s ‚Üí (finset.filter (Œª (y : Œ±), y ‚âà x) s).sum (Œª (a : Œ±), f a) = 0):s.sum (Œª (x : Œ±), f x) = 0\n\n/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`. -/ \n theorem nat.dvd_add_self_left{m n : ‚Ñï}:m ‚à£ m + n ‚Üî m ‚à£ n\n\n/-- To prove a property of a finite sum, it suffices to prove that the property is additive and holds on summands. -/ \n theorem finsum_mem_induction{Œ± : Type u_1} {M : Type u_5} [add_comm_monoid M] {f : Œ± ‚Üí M} {s : set Œ±} (p : M ‚Üí Prop) (hp‚ÇÄ : p 0) (hp‚ÇÅ : ‚àÄ (x y : M), p x ‚Üí p y ‚Üí p (x + y)) (hp‚ÇÇ : ‚àÄ (x : Œ±), x ‚àà s ‚Üí p (f x)):p (finsum (Œª (i : Œ±), finsum (Œª (H : i ‚àà s), f i)))\n\n/-- The sum of an odd and an even number is odd. -/\ntheorem","statement":"The sum of an odd and an even number is odd.","success?":true,"typecorrect_translations":[{"args":"m ","name":"odd_add_even{n","type":" ‚Ñï}:odd n ‚Üí even m ‚Üí odd (n + m)\n\n"},{"args":"n ","name":"nat.odd_add_of_odd_or_even{m","type":" ‚Ñï} (h1 : m % 2 = 1) (h2 : n % 2 = 0):(m + n) % 2 = 1\n\n"},{"args":"m ","name":"odd_add_of_odd_even{n","type":" ‚Ñï}:odd n ‚Üí even m ‚Üí odd (n + m)\n\n"},{"args":"n ","name":"nat.odd_add_even{m","type":" ‚Ñï} (h1 : odd m) (h2 : even n):odd (m + n)\n\n"}]}]